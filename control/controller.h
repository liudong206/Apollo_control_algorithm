/**
 * @file
 * @brief Defines the Controller base class.
 */

#ifndef MODULES_CONTROL_CONTROLLER_CONTROLLER_H_
#define MODULES_CONTROL_CONTROLLER_CONTROLLER_H_

#include <cmath>
#include <string>
#include <vector>
#include <iostream>
#include "common/base_types.h"
#include "vehicle_info/vehicle_state.h"
#include "common/control_conf.h"
#include "common/debug.h"
namespace control {

/**
 * @class Controller
 *
 * @brief base class for all controllers.
 */
class Controller {
 public:
  /**
   * @brief constructor
   */
  Controller() = default;

  /**
   * @brief destructor
   */
  virtual ~Controller() = default;

  /**
   * @brief compute control command based on current vehicle status
   *        and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  virtual int ComputeControlCommand(
      const std::vector<TrajectoryPoint>* planning_trajectory,
      SimpleDebug *debug,
      const VehicleState &vehicle_state) = 0;

  /**
   * @brief find_closest_point
   * @param trajectory planning TrajectoryPoint
   * @param x VehicleState x
   * @param y VehicleState y
   * @return the closest point index
   */
  std::size_t find_closest_point(
          const std::vector<TrajectoryPoint>* trajectory,
          const double x,
          const double y) {

      auto func_distance_square = [](const PathPoint& point, const double x,
                                     const double y) {
        double dx = point.x - x;
        double dy = point.y - y;
        return dx * dx + dy * dy;
      };

      double d_min = func_distance_square(trajectory->front(), x, y);
      std::size_t index_min = 0;
      for (std::size_t i = 1; i < trajectory->size(); ++i) {
        double d_temp = func_distance_square((*trajectory)[i], x, y);
        if (d_temp < d_min) {
          d_min = d_temp;
          index_min = i;
        }
      }

      return index_min;
  }
  double AngleNormalization(double angle_origin){
      double angle_norm;
      if(angle_origin > M_PI)
          angle_norm = angle_origin - 2 * M_PI;
      else if (angle_origin < -M_PI) {
          angle_norm = angle_origin + 2 * M_PI;
      }
      else {
          angle_norm = angle_origin;
      }
      return angle_norm;
  }

  template <typename T>
  T Clamp(const T value, T bound1, T bound2) {

     if (bound1 > bound2) {
     std::swap(bound1, bound2);
     }

     if (value < bound1) {
       return bound1;
     } else if (value > bound2) {
       return bound2;
     }
     return value;
 }
};

}  // namespace control

#endif  // MODULES_CONTROL_CONTROLLER_CONTROLLER_H_
